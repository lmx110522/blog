<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python flask做的二手交易商城]]></title>
    <url>%2Flmx110522.github.io%2F2018%2F08%2F09%2F%E4%BA%8C%E6%89%8B%E4%BA%A4%E6%98%93%E5%95%86%E5%9F%8E%2F</url>
    <content type="text"><![CDATA[看了几天python，想着做一个东西出来，就做出了一个小型二手 商城练练手1.解释以下的二手 商城展示，商品照片为了好看，从京东上爬下来的，有一些动态效果，我只制作了一张，在线转换成gif的话由于录制屏幕视频文件太大不太容易转格式 2.用户在没有登录的时候点击买东西，会弹出首先登录，同时也可以选择注册 3.卖东西的界面使用了可以拖拽的方式让用户上传商品更方便 4.用户添加商品到购物车的界面，由于二手商品数量每件比较少，所以限定用户在提交到购物车20分钟内完成结算，否则商品会从购物车内清除 5.加入购物车之后，用户可以去个人中心查看(顺便展示一下更换照片的界面) 6. 这个时候商品已经在你的购物车内，你在个人中心也可以看到购物车并且去结算 7. 去结算 8. 如果用户没有完成结算的话，会在订单中，同样也有时间限制，每件商品都有根据当初进入订单那个时间算起至三十分钟后自动从订单中取消 9. 商品列表页面 10. 在二手商城中难免有些买家觉着卖家定价不合适，会跟商家交谈，所以我也做了一个商品议价的模块，可以实现回复再回复的问题 11.我的总结： 上面只是简单的页面展示，具体代码在github上，这个项目中有很多的知识点 希望大家又遇到同样的功能不知道怎么实现的时候，我的代码能够帮到你 调bug是一件培养心态的一件事，做web也有二年左右了，感觉从代码中培养了好性格 12.github地址是:https://github.com/lmx110522/nyist_python_secondmall.git上面的页面可能不太好看，我是一个写后端代码的小码农却喜欢做前台页面，我去努力进步的！，希望你的支持，谢谢花费时间看我的博客，万分感谢！]]></content>
      <categories>
        <category>python flask</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>商城</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南阳理工下载中心]]></title>
    <url>%2Flmx110522.github.io%2F2018%2F04%2F09%2Funtitled-1547015228393%2F</url>
    <content type="text"><![CDATA[springboot实现使用ftp实现下载由于前后台都是我本人写的，加上就四五天的时间，所以，有点瑕疵！给我评论哟springboot特点有以下 1、使编码变得简单2、使配置变得简单3、使部署变得简单4、使监控变得简单由于时间比较紧张，有些功能或许不太完善，后期回去完善，谢谢您的查看! 里面大致功能 阿里验证码 springboot框架下的RabbitMq解决同时注册削锋的问题 springboot使用redis以及session实现避免多用户造成给数据库压力 网站多处使用ajax异步技术实现异步加载数据 sppringdatajpa的使用，多条件共同作用下的查询结果异显示在页面 本站本来要使用socket实现管理员消息推送，但是这个功能和上个spingboot模拟QQ相似，所以就没写 希望它对您有帮助 先上截图 1 首页 2 全部下载，这个有点含金量，多条件同时传递筛选，然后异步显示 3 登录，使用了阿里的手机验证码登录，以及jquery实现的滑块验证 4. 上传页面，实现了图片在线预览，以及自动识别格式 5. 更换头像少不了的功能 6.下载项详细页，里面包含评论，还有同类型精准匹配推荐 7. 下载须知，这个样式有必要展示一下，挺好看的 8. 管理员后台登录 9. 管理员主界面， 10. 审核界面不一一介绍了，希望你如果真的想了解这些功能，下载下来，看看具体功能实现步骤，上面的网站照片主要是让你了解一下网站的大致功能 以及如何显示，具体代码请查看github网站，如果喜欢，给个小星星 ！ github地址： https://github.com/lmx110522/download-nyist.git **]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>FTP</tag>
        <tag>redis</tag>
        <tag>activemq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消息中间件]]></title>
    <url>%2Flmx110522.github.io%2F2017%2F10%2F17%2Funtitled-1547032647804%2F</url>
    <content type="text"><![CDATA[消息中间件 常用的消息中间件1. ActiveMQ Apache出品的，开发常用2. RabbitMQ 完全支持JMS1.1和J2EE 1.4规范3. kafka Kafka的目的是通过Hadoop的并行加载机制来统一线上和离线的消息处理，也是为了通过集群来提供实时的消息。 消息中间件可以提高系统性能 JMSJMS 是一套消息中间件的技术规范，定义了一系列的接口规范。JMS 定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。 TextMessage–一个字符串对象 MapMessage–一套名称-值对 ObjectMessage–一个序列化的 Java 对象 BytesMessage–一个字节的数据流 StreamMessage – Java 原始值的数据流 对于消息的传递有两种类型： 一种是点对点的，即一个生产者和一个消费者一一对应； 另一种是发布、订阅模式，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收。 消息中间件用的比较多的还是activeMQ点对点模式消息生产者生产消息（点对点模式）1234567891011121314151617181920212223242526272829303132333435363738import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class QueueProducer &#123; public static void main(String[] args) throws JMSException &#123; //创建连接工厂 ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory("tcp://192.168.13.131:61616"); //创建连接 Connection connection = activeMQConnectionFactory.createConnection(); //启动连接 connection.start(); //获取session（会话对象） 参数1:是否启动事物 参数2:消息确认方式 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //创建队列对象 Queue queue = session.createQueue("sms"); //创建消息生产者对象 MessageProducer producer = session.createProducer(queue); //创建消息(文本对象) TextMessage textMessage = session.createTextMessage("你好，jms"); //发送消息 producer.send(textMessage); //关闭连接 producer.close(); session.close(); connection.close(); &#125;&#125; 消费者消费消息（点对点模式）1234567891011121314151617181920212223242526272829303132333435363738394041424344import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class QueueConsumer &#123; public static void main(String[] args) throws JMSException &#123; //创建连接工厂 ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory("tcp://192.168.13.131:61616"); //创建连接 Connection connection = activeMQConnectionFactory.createConnection(); //启动连接 connection.start(); //获取session（会话对象） 参数1:是否启动事物 参数2:消息确认方式 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //创建队列对象 Queue queue = session.createQueue("sms"); //创建消息消费者对象 MessageConsumer consumer = session.createConsumer(queue); //设置监听 consumer.setMessageListener(new MessageListener() &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; try &#123; String messageText = textMessage.getText(); System.out.println("接收到的消息是："+messageText); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); consumer.close(); session.close(); connection.close(); &#125;&#125; 发布订阅模式消息生产者生产消息（发布订阅模式）123456789101112131415161718192021222324252627282930313233343536373839import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class QueueProducer &#123; public static void main(String[] args) throws JMSException &#123; //创建连接工厂 ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory("tcp://192.168.13.131:61616"); //创建连接 Connection connection = activeMQConnectionFactory.createConnection(); //启动连接 connection.start(); //获取session（会话对象） 参数1:是否启动事物 参数2:消息确认方式 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //创建主题对象 Topic topic = session.createTopic("sms2"); //创建消息生产者对象 MessageProducer producer = session.createProducer(topic); //创建消息(文本对象) TextMessage textMessage = session.createTextMessage("你好，jms2"); //发送消息 producer.send(textMessage); //关闭连接 producer.close(); session.close(); connection.close(); &#125;&#125; 消费者消费消息（发布订阅模式）1234567891011121314151617181920212223242526272829303132333435363738394041424344import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class QueueConsumer &#123; public static void main(String[] args) throws JMSException &#123; //创建连接工厂 ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory("tcp://192.168.13.131:61616"); //创建连接 Connection connection = activeMQConnectionFactory.createConnection(); //启动连接 connection.start(); //获取session（会话对象） 参数1:是否启动事物 参数2:消息确认方式 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //创建主题对象 Topic topic = session.createTopic("sms2"); //创建消息消费者对象 MessageConsumer consumer = session.createConsumer(topic); //设置监听 consumer.setMessageListener(new MessageListener() &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; try &#123; String messageText = textMessage.getText(); System.out.println("接收到的消息是："+messageText); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); consumer.close(); session.close(); connection.close(); &#125;&#125; 注意点 发布订阅模式下，生产者发布消息，消费者必须在开启的情况下才可以接受到，否则消息就浪费掉，就消失了。 Spring整合Jms Spring生产者xml文件配置（点对点） 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:amq="http://activemq.apache.org/schema/core" xmlns:jms="http://www.springframework.org/schema/jms" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="cn.itcast.demo"&gt;&lt;/context:component-scan&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://192.168.13.131:61616"/&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name="targetConnectionFactory" ref="targetConnectionFactory"/&gt; &lt;/bean&gt; &lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt; &lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt; &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt; &lt;property name="connectionFactory" ref="connectionFactory"/&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 文本信息--&gt; &lt;bean id="queueTextDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;constructor-arg value="queue_text"/&gt; &lt;/bean&gt; &lt;!--这个是订阅模式 文本信息--&gt; &lt;bean id="topicTextDestination" class="org.apache.activemq.command.ActiveMQTopic"&gt; &lt;constructor-arg value="topic_text"/&gt; &lt;/bean&gt; &lt;/beans&gt; Spring生产者生产消息（点对点）1234567891011121314151617181920import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jms.core.JmsTemplate;import org.springframework.stereotype.Component;import javax.jms.Destination;@Componentpublic class SpringQueueProducer &#123; @Autowired private JmsTemplate jmsTemplate; @Autowired private Destination queueTextDestination; //发送消息 public void sendTextMessage(final String text)&#123; jmsTemplate.convertAndSend(text); &#125;&#125; 123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations="classpath:applicationContext-jms-producer.xml")public class TestQueue &#123; @Autowired private QueueProducer queueProducer; @Test public void testSend()&#123; queueProducer.sendTextMessage("SpringJms-点对点"); &#125; &#125; Spring消费者接收消息（点对点）Spring消费者接收xml配置12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:amq="http://activemq.apache.org/schema/core" xmlns:jms="http://www.springframework.org/schema/jms" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://192.168.25.131:61616"/&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name="targetConnectionFactory" ref="targetConnectionFactory"/&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 文本信息--&gt; &lt;bean id="queueTextDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;constructor-arg value="queue_text"/&gt; &lt;/bean&gt; &lt;!-- 监听类 --&gt; &lt;bean id="myMessageListener" class="cn.itcast.demo.MyMessageListener"&gt;&lt;/bean&gt; &lt;!-- 消息监听容器 --&gt; &lt;bean class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="destination" ref="queueTextDestination" /&gt; &lt;property name="messageListener" ref="myMessageListener" /&gt; &lt;/bean&gt; &lt;/beans&gt; Spring消费者消费消息（点对点）1234567891011121314package cn.itcast.demo;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.TextMessage;public class MyMessageListener implements MessageListener &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; System.out.println("接受到的消息为："+textMessage); &#125;&#125; 123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations="classpath:applicationContext-jms-consumer-queue.xml")public class TestQueue &#123; @Test public void testQueue()&#123; try &#123; System.in.read(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; spring整合jms，对于订阅广播模式，xml配置和点对点一样，我被对应配置已经放在里面了然后只有执行语句不一样 Spring生产者生产消息（发布订阅模式）1234567891011121314151617181920@Componentpublic class TopicProducer &#123; @Autowired private JmsTemplate jmsTemplate; @Autowired private Destination topicTextDestination; /** * 发送文本消息 * @param text */ public void sendTextMessage(final String text)&#123; jmsTemplate.send(topicTextDestination, new MessageCreator() &#123; public Message createMessage(Session session) throws JMSException &#123; return session.createTextMessage(text); &#125; &#125;); &#125;&#125; 12345678910111213141516import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import cn.itcast.demo.TopicProducer;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations="classpath:applicationContext-activemq-producer.xml")public class TestTopic &#123; @Autowired private TopicProducer topicProducer; @Test public void sendTextQueue()&#123; topicProducer.sendTextMessage(); &#125; &#125; Spring消费者消费消息（发布订阅模式）123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations="classpath:applicationContext-jms-consumer-topic.xml")public class TestTopic &#123; @Test public void testTopic()&#123; try &#123; System.in.read(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 上面的代码 1System.in.read(); 是防止程序启动结束就会关闭，所以让窗口一直等待输入 学习总结花了一两天来了解jms以及和spring的整合，用处很大！有以下两点 可以用来在发送短信的功能中，把短信验证码发送到队列中，然后点对点方式让用户接受到，起到了一定程度的削锋 发布订阅模式可以用在集群环境下，由于集群环境下，同一个页面在不同的服务器上存在多份，可以使用发布订阅模式完成同时渲染多个服务器上的相同的页面]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>消息中间件</tag>
        <tag>JMS</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux的chmod赋权限语句]]></title>
    <url>%2Flmx110522.github.io%2F2017%2F02%2F19%2Funtitled-1547022739896%2F</url>
    <content type="text"><![CDATA[linux下chmod 755的解释很多时候在Linux系统下给安装好的软件赋权限的时候回用的755、555,那么数字表示什么呢？ 普及一下chmod的数字 chmod是Linux下设置文件权限的命令，后面的数字表示不同用户或用户组的权限。 一般是三个数字： 第一个数字表示文件所有者的权限 第二个数字表示与文件所有者同属一个用户组的其他用户的权限 第三个数字表示其它用户组的权限。 权限分为三种：读（r=4），写（w=2），执行（x=1） 。 综合起来还有可读可执行（rx=5=4+1）、可读可写（rw=6=4+2）、可读可写可执行(rwx=7=4+2+1)。 举个例子 1234chmod 755 设置用户的权限为： 1.文件所有者可读可写可执行 --7 2.与文件所有者同属一个用户组的其他用户可读可执行 --5 3.其它用户组可读可执行]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot实现模拟QQ的实现(超具体)]]></title>
    <url>%2Flmx110522.github.io%2F2017%2F02%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[springboot实现QQ在线聊天，大部分功能已经实现！ 如果需要的话，去我的github空间download,有不足，希望大家指出~ 1.登录页面 2.先来看看主界面是什么样子 3.然后我们再看看聊天界面是什么样的 4.添加好友的时候什么样子呢! 5.对方加你好友的时候，你的接受好友申请的界面 6.你点击同意之后，你可以选择好友在哪个好友分组，当然你也可以添加分组 7.基本的功能都已经实现主要难点有以下 数据库如何保存聊天信息，如果频繁操作数据库，会让网页每次访问压力很大，不利于体验效果 作为一个后端人员，做网页效果难度很大，还好我闲暇时间都会去看看前端，这个前后端完全来自我一个人四天的努力，所以难免有点地方不足，请大家给我留言 逻辑比较清楚，但是实现起来比较麻烦！变量传来传去，丢参数很正常，但是，现在程序一切运行正常，大家可以从下载下来，在idea运行，有一个问题，在chrome内核的浏览器上支持度比较好，在其他浏览器的滚动条有点问题！ 注册功能我没有写，我下一条博客准备发我的用python框架flask写的小型商城，那个里面有邮箱注册，到时候大家可以从哪里瞅瞅 希望你的小星星点赞我的github，谢谢 我的github站点：https://github.com/lmx110522/nyist_chat_project.git 谢谢大家花时间看我的博客，万分感谢~~~]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
</search>
