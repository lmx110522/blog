<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python flask做的二手交易商城]]></title>
    <url>%2Flmx110522.github.io%2F2018%2F08%2F09%2F%E4%BA%8C%E6%89%8B%E4%BA%A4%E6%98%93%E5%95%86%E5%9F%8E%2F</url>
    <content type="text"><![CDATA[看了几天python，想着做一个东西出来，就做出了一个小型二手 商城练练手1.解释以下的二手 商城展示，商品照片为了好看，从京东上爬下来的，有一些动态效果，我只制作了一张，在线转换成gif的话由于录制屏幕视频文件太大不太容易转格式 2.用户在没有登录的时候点击买东西，会弹出首先登录，同时也可以选择注册 3.卖东西的界面使用了可以拖拽的方式让用户上传商品更方便 4.用户添加商品到购物车的界面，由于二手商品数量每件比较少，所以限定用户在提交到购物车20分钟内完成结算，否则商品会从购物车内清除 5.加入购物车之后，用户可以去个人中心查看(顺便展示一下更换照片的界面) 6. 这个时候商品已经在你的购物车内，你在个人中心也可以看到购物车并且去结算 7. 去结算 8. 如果用户没有完成结算的话，会在订单中，同样也有时间限制，每件商品都有根据当初进入订单那个时间算起至三十分钟后自动从订单中取消 9. 商品列表页面 10. 在二手商城中难免有些买家觉着卖家定价不合适，会跟商家交谈，所以我也做了一个商品议价的模块，可以实现回复再回复的问题 11.我的总结： 上面只是简单的页面展示，具体代码在github上，这个项目中有很多的知识点 希望大家又遇到同样的功能不知道怎么实现的时候，我的代码能够帮到你 调bug是一件培养心态的一件事，做web也有二年左右了，感觉从代码中培养了好性格 12.github地址是:https://github.com/lmx110522/nyist_python_secondmall.git上面的页面可能不太好看，我是一个写后端代码的小码农却喜欢做前台页面，我去努力进步的！，希望你的支持，谢谢花费时间看我的博客，万分感谢！]]></content>
      <categories>
        <category>python flask</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>商城</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南阳理工下载中心]]></title>
    <url>%2Flmx110522.github.io%2F2018%2F04%2F09%2F%E5%8D%97%E9%98%B3%E7%90%86%E5%B7%A5%E4%B8%8B%E8%BD%BD%E4%B8%AD%E5%BF%83%2F</url>
    <content type="text"><![CDATA[springboot实现使用ftp实现下载由于前后台都是我本人写的，加上就四五天的时间，所以，有点瑕疵！给我评论哟springboot特点有以下 1、使编码变得简单2、使配置变得简单3、使部署变得简单4、使监控变得简单由于时间比较紧张，有些功能或许不太完善，后期回去完善，谢谢您的查看! 里面大致功能 阿里验证码 springboot框架下的RabbitMq解决同时注册削锋的问题 springboot使用redis以及session实现避免多用户造成给数据库压力 网站多处使用ajax异步技术实现异步加载数据 sppringdatajpa的使用，多条件共同作用下的查询结果异显示在页面 本站本来要使用socket实现管理员消息推送，但是这个功能和上个spingboot模拟QQ相似，所以就没写 希望它对您有帮助 先上截图 1 首页 2 全部下载，这个有点含金量，多条件同时传递筛选，然后异步显示 3 登录，使用了阿里的手机验证码登录，以及jquery实现的滑块验证 4. 上传页面，实现了图片在线预览，以及自动识别格式 5. 更换头像少不了的功能 6.下载项详细页，里面包含评论，还有同类型精准匹配推荐 7. 下载须知，这个样式有必要展示一下，挺好看的 8. 管理员后台登录 9. 管理员主界面， 10. 审核界面不一一介绍了，希望你如果真的想了解这些功能，下载下来，看看具体功能实现步骤，上面的网站照片主要是让你了解一下网站的大致功能 以及如何显示，具体代码请查看github网站，如果喜欢，给个小星星 ！ github地址： https://github.com/lmx110522/download-nyist.git **]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>FTP</tag>
        <tag>redis</tag>
        <tag>activemq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot实现模拟QQ的实现(超具体)]]></title>
    <url>%2Flmx110522.github.io%2F2018%2F02%2F08%2Fspringboot%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%8B%9FQQ%E7%9A%84%E5%AE%9E%E7%8E%B0(%E8%B6%85%E5%85%B7%E4%BD%93)%2F</url>
    <content type="text"><![CDATA[springboot实现QQ在线聊天，大部分功能已经实现！ 如果需要的话，去我的github空间download,有不足，希望大家指出~ 1.登录页面 2.先来看看主界面是什么样子 3.然后我们再看看聊天界面是什么样的 4.添加好友的时候什么样子呢! 5.对方加你好友的时候，你的接受好友申请的界面 6.你点击同意之后，你可以选择好友在哪个好友分组，当然你也可以添加分组 7.基本的功能都已经实现主要难点有以下 数据库如何保存聊天信息，如果频繁操作数据库，会让网页每次访问压力很大，不利于体验效果 作为一个后端人员，做网页效果难度很大，还好我闲暇时间都会去看看前端，这个前后端完全来自我一个人四天的努力，所以难免有点地方不足，请大家给我留言 逻辑比较清楚，但是实现起来比较麻烦！变量传来传去，丢参数很正常，但是，现在程序一切运行正常，大家可以从下载下来，在idea运行，有一个问题，在chrome内核的浏览器上支持度比较好，在其他浏览器的滚动条有点问题！ 注册功能我没有写，我下一条博客准备发我的用python框架flask写的小型商城，那个里面有邮箱注册，到时候大家可以从哪里瞅瞅 希望你的小星星点赞我的github，谢谢 我的github站点：https://github.com/lmx110522/nyist_chat_project.git 谢谢大家花时间看我的博客，万分感谢~~~]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring注解驱动开发（二）]]></title>
    <url>%2Flmx110522.github.io%2F2017%2F12%2F18%2Fspring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[spring注解驱动开发（二）@Import的使用目前我们知道的往ioc容器中注册组件的方式有两种 在类上标注@component、@Service、@Controller、@Repository，然后通过@ComponentScan的方式扫描到ioc容器中 在配置类中需要注册到ioc容器的组件使用@Bean主机的方式出了上面的方法，那么我们再介绍几种方法 @Import可以实现快速注册组件的目的@Import({MyImportSelector.class})然而在ioc中的id是该类的全类名 FactoryBean接口可以实现注册组件的目的我们可以创建一个类实现FactoryBean接口1234567891011121314151617181920public class PersonFactoryBean implements FactoryBean&lt;Person&gt;&#123; //返回对象会加载到ioc容器中 public Person getObject() throws Exception &#123; // TODO Auto-generated method stub System.out.println("成功调用"); return new Person(); &#125; //指定类型 public Class&lt;?&gt; getObjectType() &#123; // TODO Auto-generated method stub return Person.class; &#125; //指定是否是单例模式 public boolean isSingleton() &#123; // TODO Auto-generated method stub return true; &#125;&#125; 然后我们可以测试12345AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class); Object bean = context.getBean("personFactoryBean"); System.out.println(bean.getClass());//打印出来的是class cn.itcast.pojo.Person Object bean1 = context.getBean("&amp;personFactoryBean"); System.out.println(bean1.getClass());//打印出来的是class cn.itcast.config.PersonFactoryBean 注：上面在获取bean的时候，有一个符号&amp;，通过加上这个符号可以获得注册组件自己 ImportSelector接口可以实现注册组件的目的我们把要注册到ioc容器中组件的全类名放在返回的数组中1234567public class MyImportSelector implements ImportSelector&#123; public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; return new String[] &#123;"cn.itcast.pojo.Role","cn.itcast.pojo.Dog"&#125;; &#125;&#125; 记得把MyImportSelector注册到ioc容器中，这里我们采用快速注入的方式@Import({MyImportSelector.class})我们可以一次注册多个组件到容器中 ImportBeanDefinitionRegistrar接口可以实现注册组件的目的123456789101112131415public class MyImportBeanDefinitionRegister implements ImportBeanDefinitionRegistrar&#123; public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; //首先判断ioc中是否有role这个组件，如果有的话，就注册bean boolean flag = registry.containsBeanDefinition("cn.itcast.pojo.Role"); if(flag) &#123; //注册person组件 RootBeanDefinition beanDefinition = new RootBeanDefinition(Person.class); registry.registerBeanDefinition("person",beanDefinition); &#125; &#125;&#125; @Bean中的initMethod、destroyMethod原先我们使用xml配置的方式表示为:1234567891011121314151617181920public class Role &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void init() &#123; System.out.println("容器初始化"); &#125; public void destory() &#123; System.out.println("容器被销毁"); &#125;&#125; 123&lt;bean id="role" class="cn.itcast.pojo.Role" init-method="init" destroy-method="destory"&gt; &lt;property name="name" value="bean生命周期"&gt;&lt;/property&gt;&lt;/bean&gt; 在@Bean中有两个属性1234@Bean(initMethod="init",destroyMethod="destory") public Role role() &#123; return new Role(); &#125; 注：在销毁的时候，单实例容器会销毁，但是多实例，容器不负责销毁，所以在多实例下销毁方法不调用 在初始化的时候，单实例容器运行时，会调用初始化（init）方法，多实例在调用对象的时候创建(执行init的方法) @Value、@PropertySource的使用以前我们使用下面方式给组件赋值123&lt;bean id="dog" class="cn.itcast.pojo.Dog"&gt; &lt;property name="name" value="旺财"&gt;&lt;/property&gt; &lt;/bean&gt; 在注解版中我们可以使用1234@Value("旺财")private String name;@Value("#&#123;2*3&#125;")private String nickName; 当然这种硬编码不太好，所以我们可以加载配置文件中的值，那么引入@PropertySource实现引入配置文件然后使用属性占位符的方式得到12@Value("$&#123;dog.name&#125;")private String name; 当然你也可以使用SPEL表达式得到。12 @Value("#&#123;systemProperties['dog.name']&#125;")private String name; @Autowired、@Qualifier、@Primary注解的使用@Autowired用作组件的自动装配，装配的规则是 首先按照组件的类型从ioc容器中查找，查找到装配完成 如果遇到多个同类型的组件，那么会使用属性名作为查找ioc容器组件的id 如果没有查到到，会报错！但是我们又不想让它报错，那么我们可以使用@Autowired(required=false)当然我们也可以自己指定需要查找组件的id,用@Qualifier(&quot;indexService1&quot;),这样我们就可以去ioc容器中查找id是indexService1的组件同时呢，spring也给我们提供了@Primary，意思是要找此类型的组件，首选此组件12345@Primary @Bean public IndexService indexService1() &#123; return new IndexService(); &#125; 注：@Primary注解使用的时候，就不要使用@Qualifier注解了 spring也支持@Resource(JSR250)和@Inject(JSR330),这些都是java规范@Resource默认按照属性的名称作为组件的id去ioc容器查找，当然我们也可以使用@Resource（name=’indexDao1’）设置@Inject需要导入javax.inject的包，在使用上和@Autowired一样@Autowired可以使用在构造器，方法，属性上面、参数位置，如果组件只有一个有参构造器，参数位置的@Autowired可以省略，还有@Bean中的参数，也不用写@Autowired，都可以从容器中自动装配 @Profile注解的使用Spring为我们提供的可以根据当前环境，动态的激活和切换一系列组件的功能默认的profile是default我们在某个组件上面加上@Profile(&#39;test&#39;),一旦加上之后，就是当环境激活的时候，对应的bean才可以注册到容器中那么如何激活呢 在运行到时候，设置命令行参数的方式 -Dspring.profiles.active=test 可以借助applicationContext方式激活环境，例如：1234567AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();//设置需要激活的环境context.getEnvironment().setActiveProfiles("test","dev");//注册主配置类context.register(MyConfig.class);//启动刷新容器context.refresh();]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring注解驱动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring注解驱动开发（一）]]></title>
    <url>%2Flmx110522.github.io%2F2017%2F12%2F15%2Fspring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[spring注解驱动开发（一）初步介绍 spring注解驱动开发随着springboot这个简洁化开发，约定大于配置的大环境下，spring注解版知识点使用的也开始越来越多，所以我已经学习了基础springboot之后果断停止，开始学习spring注解驱动开发,下面是我总结的一些注解知识,这个页面会一直更新，用于以后的查阅 1、@Configurable注解以及@Bean的使用Configurable表示这个一个配置类，代替原先xml配置之前我们用xml做DI(依赖注入)，现在我们可以通过class的方式来声明一个配置类 xml配置1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"&gt; &lt;bean id="person" class="cn.itcast.pojo.Person"&gt; &lt;property name="username" value="lmx"&gt;&lt;/property&gt; &lt;property name="password" value="123"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 现在可以使用123456789101112131415package cn.itcast.config;import org.springframework.beans.factory.annotation.Configurable;import org.springframework.context.annotation.Bean;import cn.itcast.pojo.Person;@Configurablepublic class MyConfig &#123; @Bean(name="lmx") public Person person() &#123; return new Person("lmz","456"); &#125;&#125; 上面的bean代替旧的即&lt;bean/&gt;可以实现向容器注册组件，其中bean的name属性指的是注册组件在容器中的ID，默认是方法名作为组件的ID 然后通过下面的测试，果然简单有效，赞！1234567891011121314151617181920212223242526package cn.itcast.test;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import cn.itcast.config.MyConfig;import cn.itcast.pojo.Person;public class MainTest &#123; public static void main(String[] args) &#123;// ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");// Person person = (Person)applicationContext.getBean("person");// System.out.println("姓名："+person.getUsername());// System.out.println("密码："+person.getPassword()); AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class); Person bean = context.getBean(Person.class); System.out.println("姓名："+bean.getUsername()); System.out.println("密码："+bean.getPassword()); String[] beanNamesForType = context.getBeanNamesForType(Person.class); for (String string : beanNamesForType) &#123; System.out.println(string); &#125; &#125;&#125; 2、@ComponentScan包扫描注解context:component-scan主要用于扫描对应包下面的注解到容器中，一般有以下注解 @Controller @Service @Repository @Component 对应的xml配置 &lt;context:component-scan base-package=&quot;cn.itcast&quot;/&gt;’ 用class类文件的方式，把下面配置配在config文件的上面，这样可以实现包扫描 @ComponentScan(basePackages= {“cn.itcast”})’ @excludeFilters可以除去不想扫描进容器的注解1234@ComponentScan(basePackages= &#123;"cn.itcast"&#125;,excludeFilters= &#123; @Filter(type=FilterType.ANNOTATION,classes=Controller.class), @Filter(type=FilterType.ANNOTATION,classes=Service.class)&#125;) use-default-filters这个语句主要是关闭默认扫描对应包下面的所有注解 @includeFilters中要把use-default-filters设置成false xml中这样写 &lt;context:component-scan base-package=&quot;cn.itcast&quot; use-default-filters=&quot;false&quot; /&gt; 使用class文件这样写就ok了1234@ComponentScan(basePackages = &#123;"cn.itcast"&#125;,includeFilters = &#123;@Filter(type=FilterType.ANNOTATION,classes=Controller.class),@Filter(type=FilterType.ANNOTATION,classes=Service.class)&#125;,useDefaultFilters = false) 由于java8以上才有@Repeatable这个注解，表示可以注解重复，但是java8以下不支持，所以我们要做兼容性有一个注解@ComponentScans，可以包含多个@ComponentScan 3、 @Scope注解扫描到容器的默认是单实例的我们可以通过scope改变默认值xml中我们是这样来表示scope的1234&lt;bean id="person" class="cn.itcast.pojo.Person" scope="prototype"&gt; &lt;property name="username" value="lmx"&gt;&lt;/property&gt; &lt;property name="password" value="123"&gt;&lt;/property&gt; &lt;/bean&gt; class类方式在@Bean注解上添加@Scope 注： 单实例是ioc容器启动的时候就就把对象创建放进容器了，但多实例是什么时候调用就什么时候创建 例如：@Scope(&#39;prototype&#39;)这个表明扫描进容器的组件是多实例的，当然我们也可以使用@Scope(&#39;singleton&#39;)或者不写，可以实现单实例12345@Scope(value="SCOPE_PROTOTYPE") @Bean(name="lmx") public Person person() &#123; return new Person("lmz","456"); &#125; 4、 @Lazy懒加载的使用把这个注解放在@Bean的上面表示懒加载，即IOC容器启动的时候创建，什么时候使用什么时候创建 注:这个属性主要针对的是单实例的 5、 @Conditional条件注解的使用这个注解在springboot的底层源码用的最多，所以有必要好好深挖一下我写了一个demo1234567891011@Conditional(WindowsCondition.class) @Bean(name="bill") public Person person01() &#123; return new Person("Bill Gates","123"); &#125; @Conditional(LinuxCondition.class) @Bean(name="linus") public Person person02() &#123; return new Person("linus","456"); &#125; 分别创建WindowsCondition、LinuxCondition，都要实现Condition接口12345678910111213141516171819202122232425262728public class LinuxCondition implements Condition&#123; //参数 context 上下文环境 // 参数 metadata 当前注释此注解的信息 public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; // //获得ioc使用的beanfactory// ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();// // //获取类加载器// ClassLoader classLoader = context.getClassLoader();// // //获取bean定义的注册类// BeanDefinitionRegistry registry = context.getRegistry(); // //判断对应的bean是不是在ioc容器中已经存在// boolean isExist = registry.containsBeanDefinition("lmx");// //获取当前系统环境信息 Environment environment = context.getEnvironment(); //获取操作系统属性 String property = environment.getProperty("os.name"); if(property.contains("Linux")) return true; return false; &#125;&#125; 123456789101112public class WindowsCondition implements Condition&#123; public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; // TODO Auto-generated method stub Environment environment = context.getEnvironment(); String property = environment.getProperty("os.name"); if(property.contains("Windows")) return true; return false; &#125;&#125; 然后做测试12345AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class); String[] strings = context.getBeanNamesForType(Person.class); for (String string : strings) &#123; System.out.println(string); &#125; 结果：由于我的系统是Windows，所以ioc容器中注册的组件id是 bill 下一篇还有spring注解驱动开发（二）]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring注解驱动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消息中间件]]></title>
    <url>%2Flmx110522.github.io%2F2017%2F10%2F17%2F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[消息中间件 常用的消息中间件1. ActiveMQ Apache出品的，开发常用2. RabbitMQ 完全支持JMS1.1和J2EE 1.4规范3. kafka Kafka的目的是通过Hadoop的并行加载机制来统一线上和离线的消息处理，也是为了通过集群来提供实时的消息。 消息中间件可以提高系统性能 JMSJMS 是一套消息中间件的技术规范，定义了一系列的接口规范。JMS 定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。 TextMessage–一个字符串对象 MapMessage–一套名称-值对 ObjectMessage–一个序列化的 Java 对象 BytesMessage–一个字节的数据流 StreamMessage – Java 原始值的数据流 对于消息的传递有两种类型： 一种是点对点的，即一个生产者和一个消费者一一对应； 另一种是发布、订阅模式，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收。 消息中间件用的比较多的还是activeMQ点对点模式消息生产者生产消息（点对点模式）1234567891011121314151617181920212223242526272829303132333435363738import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class QueueProducer &#123; public static void main(String[] args) throws JMSException &#123; //创建连接工厂 ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory("tcp://192.168.13.131:61616"); //创建连接 Connection connection = activeMQConnectionFactory.createConnection(); //启动连接 connection.start(); //获取session（会话对象） 参数1:是否启动事物 参数2:消息确认方式 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //创建队列对象 Queue queue = session.createQueue("sms"); //创建消息生产者对象 MessageProducer producer = session.createProducer(queue); //创建消息(文本对象) TextMessage textMessage = session.createTextMessage("你好，jms"); //发送消息 producer.send(textMessage); //关闭连接 producer.close(); session.close(); connection.close(); &#125;&#125; 消费者消费消息（点对点模式）1234567891011121314151617181920212223242526272829303132333435363738394041424344import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class QueueConsumer &#123; public static void main(String[] args) throws JMSException &#123; //创建连接工厂 ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory("tcp://192.168.13.131:61616"); //创建连接 Connection connection = activeMQConnectionFactory.createConnection(); //启动连接 connection.start(); //获取session（会话对象） 参数1:是否启动事物 参数2:消息确认方式 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //创建队列对象 Queue queue = session.createQueue("sms"); //创建消息消费者对象 MessageConsumer consumer = session.createConsumer(queue); //设置监听 consumer.setMessageListener(new MessageListener() &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; try &#123; String messageText = textMessage.getText(); System.out.println("接收到的消息是："+messageText); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); consumer.close(); session.close(); connection.close(); &#125;&#125; 发布订阅模式消息生产者生产消息（发布订阅模式）123456789101112131415161718192021222324252627282930313233343536373839import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class QueueProducer &#123; public static void main(String[] args) throws JMSException &#123; //创建连接工厂 ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory("tcp://192.168.13.131:61616"); //创建连接 Connection connection = activeMQConnectionFactory.createConnection(); //启动连接 connection.start(); //获取session（会话对象） 参数1:是否启动事物 参数2:消息确认方式 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //创建主题对象 Topic topic = session.createTopic("sms2"); //创建消息生产者对象 MessageProducer producer = session.createProducer(topic); //创建消息(文本对象) TextMessage textMessage = session.createTextMessage("你好，jms2"); //发送消息 producer.send(textMessage); //关闭连接 producer.close(); session.close(); connection.close(); &#125;&#125; 消费者消费消息（发布订阅模式）1234567891011121314151617181920212223242526272829303132333435363738394041424344import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class QueueConsumer &#123; public static void main(String[] args) throws JMSException &#123; //创建连接工厂 ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory("tcp://192.168.13.131:61616"); //创建连接 Connection connection = activeMQConnectionFactory.createConnection(); //启动连接 connection.start(); //获取session（会话对象） 参数1:是否启动事物 参数2:消息确认方式 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //创建主题对象 Topic topic = session.createTopic("sms2"); //创建消息消费者对象 MessageConsumer consumer = session.createConsumer(topic); //设置监听 consumer.setMessageListener(new MessageListener() &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; try &#123; String messageText = textMessage.getText(); System.out.println("接收到的消息是："+messageText); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); consumer.close(); session.close(); connection.close(); &#125;&#125; 注意点 发布订阅模式下，生产者发布消息，消费者必须在开启的情况下才可以接受到，否则消息就浪费掉，就消失了。 Spring整合Jms Spring生产者xml文件配置（点对点） 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:amq="http://activemq.apache.org/schema/core" xmlns:jms="http://www.springframework.org/schema/jms" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="cn.itcast.demo"&gt;&lt;/context:component-scan&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://192.168.13.131:61616"/&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name="targetConnectionFactory" ref="targetConnectionFactory"/&gt; &lt;/bean&gt; &lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt; &lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt; &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt; &lt;property name="connectionFactory" ref="connectionFactory"/&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 文本信息--&gt; &lt;bean id="queueTextDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;constructor-arg value="queue_text"/&gt; &lt;/bean&gt; &lt;!--这个是订阅模式 文本信息--&gt; &lt;bean id="topicTextDestination" class="org.apache.activemq.command.ActiveMQTopic"&gt; &lt;constructor-arg value="topic_text"/&gt; &lt;/bean&gt; &lt;/beans&gt; Spring生产者生产消息（点对点）1234567891011121314151617181920import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jms.core.JmsTemplate;import org.springframework.stereotype.Component;import javax.jms.Destination;@Componentpublic class SpringQueueProducer &#123; @Autowired private JmsTemplate jmsTemplate; @Autowired private Destination queueTextDestination; //发送消息 public void sendTextMessage(final String text)&#123; jmsTemplate.convertAndSend(text); &#125;&#125; 123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations="classpath:applicationContext-jms-producer.xml")public class TestQueue &#123; @Autowired private QueueProducer queueProducer; @Test public void testSend()&#123; queueProducer.sendTextMessage("SpringJms-点对点"); &#125; &#125; Spring消费者接收消息（点对点）Spring消费者接收xml配置12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:amq="http://activemq.apache.org/schema/core" xmlns:jms="http://www.springframework.org/schema/jms" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://192.168.25.131:61616"/&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name="targetConnectionFactory" ref="targetConnectionFactory"/&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 文本信息--&gt; &lt;bean id="queueTextDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;constructor-arg value="queue_text"/&gt; &lt;/bean&gt; &lt;!-- 监听类 --&gt; &lt;bean id="myMessageListener" class="cn.itcast.demo.MyMessageListener"&gt;&lt;/bean&gt; &lt;!-- 消息监听容器 --&gt; &lt;bean class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="destination" ref="queueTextDestination" /&gt; &lt;property name="messageListener" ref="myMessageListener" /&gt; &lt;/bean&gt; &lt;/beans&gt; Spring消费者消费消息（点对点）1234567891011121314package cn.itcast.demo;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.TextMessage;public class MyMessageListener implements MessageListener &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; System.out.println("接受到的消息为："+textMessage); &#125;&#125; 123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations="classpath:applicationContext-jms-consumer-queue.xml")public class TestQueue &#123; @Test public void testQueue()&#123; try &#123; System.in.read(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; spring整合jms，对于订阅广播模式，xml配置和点对点一样，我被对应配置已经放在里面了然后只有执行语句不一样 Spring生产者生产消息（发布订阅模式）1234567891011121314151617181920@Componentpublic class TopicProducer &#123; @Autowired private JmsTemplate jmsTemplate; @Autowired private Destination topicTextDestination; /** * 发送文本消息 * @param text */ public void sendTextMessage(final String text)&#123; jmsTemplate.send(topicTextDestination, new MessageCreator() &#123; public Message createMessage(Session session) throws JMSException &#123; return session.createTextMessage(text); &#125; &#125;); &#125;&#125; 12345678910111213141516import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import cn.itcast.demo.TopicProducer;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations="classpath:applicationContext-activemq-producer.xml")public class TestTopic &#123; @Autowired private TopicProducer topicProducer; @Test public void sendTextQueue()&#123; topicProducer.sendTextMessage(); &#125; &#125; Spring消费者消费消息（发布订阅模式）123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations="classpath:applicationContext-jms-consumer-topic.xml")public class TestTopic &#123; @Test public void testTopic()&#123; try &#123; System.in.read(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 上面的代码 1System.in.read(); 是防止程序启动结束就会关闭，所以让窗口一直等待输入 学习总结花了一两天来了解jms以及和spring的整合，用处很大！有以下两点 可以用来在发送短信的功能中，把短信验证码发送到队列中，然后点对点方式让用户接受到，起到了一定程度的削锋 发布订阅模式可以用在集群环境下，由于集群环境下，同一个页面在不同的服务器上存在多份，可以使用发布订阅模式完成同时渲染多个服务器上的相同的页面]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>消息中间件</tag>
        <tag>JMS</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux的chmod赋权限语句]]></title>
    <url>%2Flmx110522.github.io%2F2017%2F02%2F19%2Flinux%E7%9A%84chmod%E8%B5%8B%E6%9D%83%E9%99%90%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[linux下chmod 755的解释很多时候在Linux系统下给安装好的软件赋权限的时候回用的755、555,那么数字表示什么呢？ 普及一下chmod的数字 chmod是Linux下设置文件权限的命令，后面的数字表示不同用户或用户组的权限。 一般是三个数字： 第一个数字表示文件所有者的权限 第二个数字表示与文件所有者同属一个用户组的其他用户的权限 第三个数字表示其它用户组的权限。 权限分为三种：读（r=4），写（w=2），执行（x=1） 。 综合起来还有可读可执行（rx=5=4+1）、可读可写（rw=6=4+2）、可读可写可执行(rwx=7=4+2+1)。 举个例子 1234chmod 755 设置用户的权限为： 1.文件所有者可读可写可执行 --7 2.与文件所有者同属一个用户组的其他用户可读可执行 --5 3.其它用户组可读可执行]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>命令</tag>
      </tags>
  </entry>
</search>
