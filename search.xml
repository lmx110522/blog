<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[GIS音乐盒页面]]></title>
    <url>%2Flmx110522.github.io%2F2018%2F12%2F23%2FGIS%E9%9F%B3%E4%B9%90%E7%9B%92%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[GIS音乐盒说明：这个音乐盒网站是我前一段时间做的前后端项目，结果在一个我自己清理文件的时候，不小心删除一个文件夹，下面所有的项目都被我给删除了，当我发现的时候，已经是第二天我准备上线的时候，回收站也已经被我清空了，我很是伤心。昨天我在查找资料的时候，看到了我之前做的前端静态文件，所以我打算拿出来给大家，什么时候用，拿走 注： 页面截屏一个页面截不全，你可以自己下载下来查看 以前测试阶段录的小视频我录了一个测试的小视频，然后转gif,展示出来推荐一个在线wav转gif的网站，很不错，点我去 首页 所有歌手的页面 歌曲详情页（含有评论的回复和再回复） 歌手的页面 所有歌曲的页面 专辑详情页 登录页(自己写了个模态框) 个人主页 总结： 写前端css最浪费时间，我这个页面写了差不多一个星期，包括设计页面的布局 这个后端我已经给删除了，你可以自己加后端功能，建议快速开发springboot 短信我当初使用的是阿里的短信 存储文件我使用的是七牛云，很好用]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端页面</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8——Stream流]]></title>
    <url>%2Flmx110522.github.io%2F2018%2F09%2F15%2FJava8%E2%80%94%E2%80%94Stream%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Java8——Stream流我们先上手个小demo123456789101112import java.util.Arrays;public class DemoStream &#123; public static void main(String[] args) &#123; String[] strList = &#123;"李茂展","董浩","李沫熙","李哲","杨宁宁"&#125;; //接下来我们将使用stream流方式对strList进行操作，返回带 李 ，长度为3的 Arrays.stream(strList).filter((name)-&gt;name.contains("李")) .filter((name)-&gt;name.length()==3) .forEach(name-&gt; System.out.println(name)); &#125;&#125; Stream中集合的处理方案 这张图展示了过滤、映射、跳过、计数等多步操作，这是一个集合元素的处理方案，也就是一种函数模型中间执行过程中集合并不会真正的被处理，而是到最后count的时候才会被执行，这就是函数模型的操作，而之所以这样的得益于Lambda的延迟加载 Stream流获取Stream流获取有两种方式 Collection的有stream()方法获取stream流 1234567891011121314151617181920212223242526import java.util.*;import java.util.stream.Stream;public class DemoStream &#123; public static void main(String[] args) &#123; //list集合获取stream方式 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); Stream&lt;String&gt; stream1 = list.stream(); //hash获取stream方式 HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;(); Stream&lt;String&gt; stream2 = hashSet.stream(); //map集合我们可以分别把键值对转换成流对象 HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); Set&lt;String&gt; keySet = map.keySet(); Stream&lt;String&gt; stream3 = keySet.stream(); Collection&lt;String&gt; values = map.values(); Stream&lt;String&gt; stream = values.stream(); &#125;&#125; 有一个Java.util.stream有一个静态方法of也可以获得stream流 123456public static void main(String[] args) &#123; //list集合获取stream方式 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); Stream&lt;ArrayList&lt;String&gt;&gt; stream = Stream.of(list); &#125; Stream方法的学习总结首先分成两类 延迟方法 终结方法 foreach()方法 —— 终结方法遍历之后就不能使用stream流中的其他方法12345678import java.util.stream.Stream;public class ForStream &#123; public static void main(String[] args) &#123; Stream.of("李茂展","李沫熙","杨宁宁").forEach(name-&gt; System.out.println(name)); &#125;&#125; filter()方法 —— 延迟方法执行过滤之后，仍然可以使用stream的其他方法1Stream.of("李茂展","李沫熙","杨宁宁").filter(name-&gt;name.contains("李")).forEach(name-&gt; System.out.println(name)); 类名引用静态方法的使用我们使用Math.abs()来求绝对值首先我们创建一个函数式接口1234@FunctionalInterfacepublic interface AbsFunc &#123; public abstract int myAbs(int num);&#125; 然后我们可以使用lambda表达式来引用Math的静态方法12345678910111213public class DemoStream &#123; public static void getAbs(Integer num,AbsFunc absFunc)&#123; int myAbs = absFunc.myAbs(num); System.out.println(myAbs); &#125; public static void main(String[] args) &#123; getAbs(-10,Math::abs); &#125;&#125; 结构打印出来是 10 同样的使用super引用父类方法的时候，由于在子类中super是存在的，在lambda中我们可以使用super::show来完成调用 同样的使用this的时候，在lambda中我们可以使用this::show来完成调用 同样的使用new的时候，在lambda中我们可以使用Person::new来完成调用]]></content>
      <categories>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>Stream流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8——Lambda表达式]]></title>
    <url>%2Flmx110522.github.io%2F2018%2F09%2F12%2FJava8%E2%80%94%E2%80%94Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Java8——Lambda表达式语法糖指的是使用更方便，但原理不变的代码语法 lambda表达式java8有一个词汇不得不提，就是 函数式接口函数式接口：有且只有一个抽象方法的接口，我们可以在接口上标注@FunctionalInterface，表示是一个函数式接口，主要作为参数或者返回值使用1234567package cn.itcast.helloworld.java8;@FunctionalInterfacepublic interface MyFunc &#123; public abstract void save();&#125; lambda表达式的重要特征: 可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。 可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。 可选的大括号：如果主体包含了一个语句，就不需要使用大括号。 可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。 注：借鉴菜鸟教程，感觉总结特别好 接下来展示一个小demo12345678910111213141516171819202122public static void save(MyFunc myFunc)&#123; myFunc.save(); &#125; public static void main(String[] args) &#123; //传递接口的匿名内部类 save(new MyFunc() &#123; @Override public void save() &#123; System.out.println("执行完成"); &#125; &#125;); //由于方法的参数是一个函数式接口，所以可以使用lambda表达式 save(()-&gt;&#123; System.out.println("lambda表达式的使用"); &#125;); //由于函数式接口的方法没有参数，而且只有一条执行语句 save(()-&gt;System.out.println("lambda表达式的使用")); &#125; lambda表达式是延迟执行，可以对代码执行结果不急用用lambda语法，有助于提高性能lambda执行的前提是必须有函数式接口我们做了一个demo最适合解释lambda表达式的用法123456789101112131415161718192021/** 我们做了这么一个案例：* 当level的值为1的时候，打印日志,* 其他都不打印，为了防止我们苦费心思拿到日志之后，结果level不为 1，就损耗了性能* 所以我们使用有延迟加载作用的lambda** */public class Demo &#123; public static void save(int level,MyFunc myFunc)&#123; if(level == 1) myFunc.printLog(); &#125; //只有level的数字是1的时候，lambda表达式才会执行 public static void main(String[] args) &#123; save(1,()-&gt; System.out.println("这是日志")); &#125;&#125; Java中也给我们提供弄了很多函数式接口Comparator比较型接口在java中，Comparator接口是个函数式接口，内部只有一个抽象方法，所以按照lambda表达式规则，可以这样写12345678910111213141516171819202122public class MyCompare &#123; public static Comparator&lt;String&gt; myComparator()&#123; //匿名内部类// return new Comparator&lt;String&gt;() &#123;// @Override// public int compare(String o1, String o2) &#123;// return o2.length()-o1.length();// &#125;// &#125;; //采用Lambda表达式 return (o1,o2)-&gt;o2.length()-o1.length(); &#125; public static void main(String[] args) &#123; String[] arrList = &#123;"aaaaa","b","cccc","dddd"&#125;; System.out.println("原先顺序："+Arrays.toString(arrList)); Arrays.sort(arrList,myComparator()); System.out.println("现在顺序："+Arrays.toString(arrList)); &#125;&#125; 生产型接口指的是接口的泛型是什么类型，那么接口最后的返回值就是什么类型 Supplier生产型接口12345678910111213import java.util.function.Supplier;public class ProduceInterface &#123; public static String myPrint(Supplier&lt;String&gt; supplier)&#123; return supplier.get(); &#125; public static void main(String[] args) &#123; String str = myPrint(()-&gt;"李茂展"); System.out.println(str); &#125;&#125; Consumer消费型接口消费型接口，指的是泛型执行什么类型，就可以消费什么类型的数据12345678910111213141516import java.util.function.Consumer;public class ConsumerInterface &#123; public static void myConsumer(String name, Consumer&lt;String&gt; consumer)&#123; consumer.accept(name); &#125; public static void main(String[] args) &#123; //我们实现翻转输出 myConsumer("李茂展",(name)-&gt;&#123; String nameReverse = new StringBuffer(name).reverse().toString(); System.out.println(nameReverse); &#125;); &#125;&#125; Consumer中有一个默认方法andThen,我们可以这样使用123456789101112131415import java.util.function.Consumer;public class ConsumerInterface &#123; public static void myConsumer(String name, Consumer&lt;String&gt; consumer1, Consumer&lt;String&gt; consumer2)&#123; //谁写在前面谁先消费 consumer1.andThen(consumer2).accept(name); &#125; public static void main(String[] args) &#123; //我们实现先大写后小写输出 myConsumer("Tom",(name)-&gt; System.out.println(name.toUpperCase()),(name)-&gt; System.out.println(name.toLowerCase())); &#125;&#125; Predicate判断型接口predicate是用于判断的函数式接口，内部有一个test抽象方法，返回值是bool类型1234567891011121314import java.util.function.Predicate;public class PredicateInterface &#123; public static boolean myPredicate(String str, Predicate&lt;String&gt; predicate)&#123; return predicate.test(str); &#125; public static void main(String[] args) &#123; String str = "abcdefg"; boolean bool = myPredicate(str, (str1) -&gt; str1.length() &gt; 5); System.out.println(bool); &#125;&#125; predicate有三个默认方法： and: 表示条件同时满足 123456789101112131415import java.util.function.Predicate;public class PredicateInterface &#123; public static boolean myPredicate(String str, Predicate&lt;String&gt; predicate1,Predicate&lt;String&gt; predicate2)&#123; return predicate1.and(predicate2).test(str); &#125; public static void main(String[] args) &#123; String str = "abcdefg"; //判断长度大于5并且包含f字母，结果输出为true boolean bool = myPredicate(str, (str1) -&gt; str1.length() &gt; 5,(str1) -&gt; str1.contains("f")); System.out.println(bool); &#125;&#125; or: 表示条件只需要满足一个就可以返回true和上面的代码差不多相同，区别就是把上面的and替换成or,return predicate1.or(predicate2).test(str); negate： 表示取反 123456789101112131415import java.util.function.Predicate;public class PredicateInterface &#123; public static boolean myPredicate(String str, Predicate&lt;String&gt; predicate)&#123; return predicate.negate().test(str); &#125; public static void main(String[] args) &#123; String str = "abcdefg"; //判断长度大于5,然后结果应该是true，由于加上了negate,所以结果是false boolean bool = myPredicate(str, (str1) -&gt; str1.length() &gt; 5); System.out.println(bool); &#125;&#125; Function转换型接口Function中最主要的抽象方法是apply(T,t)，T表示转换前的类型，t表示转换后的类型123456789101112131415import java.util.function.Function;public class MyFunction &#123; public static void myFunc(String str, Function&lt;String,Integer&gt; function)&#123; Integer val = function.apply(str); System.out.println(val); &#125; public static void main(String[] args) &#123; //使用lambda表达式把字符串 "123"输出为数字 123 myFunc("123",(str)-&gt;Integer.parseInt(str)); &#125;&#125; Function有个默认方法andThen12345678910111213public class MyFunction &#123; public static void myFunc(String str, Function&lt;String,Integer&gt; function1,Function&lt;Integer,String&gt; function2)&#123; String str_val = function1.andThen(function2).apply(str); System.out.println(str_val); &#125; public static void main(String[] args) &#123; //使用lambda表达式把字符串转成数字然后再加上10再转换为字符串 myFunc("123",(str)-&gt;Integer.parseInt(str),(val)-&gt;String.valueOf(val +=10)); &#125;&#125;]]></content>
      <categories>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>Lambda表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python flask做的二手交易商城]]></title>
    <url>%2Flmx110522.github.io%2F2018%2F08%2F09%2F%E4%BA%8C%E6%89%8B%E4%BA%A4%E6%98%93%E5%95%86%E5%9F%8E%2F</url>
    <content type="text"><![CDATA[看了几天python，想着做一个东西出来，就做出了一个小型二手 商城练练手1.解释以下的二手 商城展示，商品照片为了好看，从京东上爬下来的，有一些动态效果，我只制作了一张，在线转换成gif的话由于录制屏幕视频文件太大不太容易转格式 2.用户在没有登录的时候点击买东西，会弹出首先登录，同时也可以选择注册 3.卖东西的界面使用了可以拖拽的方式让用户上传商品更方便 4.用户添加商品到购物车的界面，由于二手商品数量每件比较少，所以限定用户在提交到购物车20分钟内完成结算，否则商品会从购物车内清除 5.加入购物车之后，用户可以去个人中心查看(顺便展示一下更换照片的界面) 6. 这个时候商品已经在你的购物车内，你在个人中心也可以看到购物车并且去结算 7. 去结算 8. 如果用户没有完成结算的话，会在订单中，同样也有时间限制，每件商品都有根据当初进入订单那个时间算起至三十分钟后自动从订单中取消 9. 商品列表页面 10. 在二手商城中难免有些买家觉着卖家定价不合适，会跟商家交谈，所以我也做了一个商品议价的模块，可以实现回复再回复的问题 11.我的总结： 上面只是简单的页面展示，具体代码在github上，这个项目中有很多的知识点 希望大家又遇到同样的功能不知道怎么实现的时候，我的代码能够帮到你 调bug是一件培养心态的一件事，做web也有二年左右了，感觉从代码中培养了好性格 12.github地址是:https://github.com/lmx110522/nyist_python_secondmall.git上面的页面可能不太好看，我是一个写后端代码的小码农却喜欢做前台页面，我去努力进步的！，希望你的支持，谢谢花费时间看我的博客，万分感谢！]]></content>
      <categories>
        <category>python flask</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>商城</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南阳理工下载中心]]></title>
    <url>%2Flmx110522.github.io%2F2018%2F04%2F09%2F%E5%8D%97%E9%98%B3%E7%90%86%E5%B7%A5%E4%B8%8B%E8%BD%BD%E4%B8%AD%E5%BF%83%2F</url>
    <content type="text"><![CDATA[springboot实现使用ftp实现下载由于前后台都是我本人写的，加上就四五天的时间，所以，有点瑕疵！给我评论哟springboot特点有以下 1、使编码变得简单2、使配置变得简单3、使部署变得简单4、使监控变得简单由于时间比较紧张，有些功能或许不太完善，后期回去完善，谢谢您的查看! 里面大致功能 阿里验证码 springboot框架下的RabbitMq解决同时注册削锋的问题 springboot使用redis以及session实现避免多用户造成给数据库压力 网站多处使用ajax异步技术实现异步加载数据 sppringdatajpa的使用，多条件共同作用下的查询结果异显示在页面 本站本来要使用socket实现管理员消息推送，但是这个功能和上个spingboot模拟QQ相似，所以就没写 希望它对您有帮助 先上截图 1 首页 2 全部下载，这个有点含金量，多条件同时传递筛选，然后异步显示 3 登录，使用了阿里的手机验证码登录，以及jquery实现的滑块验证 4. 上传页面，实现了图片在线预览，以及自动识别格式 5. 更换头像少不了的功能 6.下载项详细页，里面包含评论，还有同类型精准匹配推荐 7. 下载须知，这个样式有必要展示一下，挺好看的 8. 管理员后台登录 9. 管理员主界面， 10. 审核界面不一一介绍了，希望你如果真的想了解这些功能，下载下来，看看具体功能实现步骤，上面的网站照片主要是让你了解一下网站的大致功能 以及如何显示，具体代码请查看github网站，如果喜欢，给个小星星 ！ github地址： https://github.com/lmx110522/download-nyist.git **]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>FTP</tag>
        <tag>redis</tag>
        <tag>activemq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot实现模拟QQ的实现(超具体)]]></title>
    <url>%2Flmx110522.github.io%2F2018%2F02%2F08%2Fspringboot%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%8B%9FQQ%E7%9A%84%E5%AE%9E%E7%8E%B0(%E8%B6%85%E5%85%B7%E4%BD%93)%2F</url>
    <content type="text"><![CDATA[springboot实现QQ在线聊天，大部分功能已经实现！ 如果需要的话，去我的github空间download,有不足，希望大家指出~ 1.登录页面 2.先来看看主界面是什么样子 3.然后我们再看看聊天界面是什么样的 4.添加好友的时候什么样子呢! 5.对方加你好友的时候，你的接受好友申请的界面 6.你点击同意之后，你可以选择好友在哪个好友分组，当然你也可以添加分组 7.基本的功能都已经实现主要难点有以下 数据库如何保存聊天信息，如果频繁操作数据库，会让网页每次访问压力很大，不利于体验效果 作为一个后端人员，做网页效果难度很大，还好我闲暇时间都会去看看前端，这个前后端完全来自我一个人四天的努力，所以难免有点地方不足，请大家给我留言 逻辑比较清楚，但是实现起来比较麻烦！变量传来传去，丢参数很正常，但是，现在程序一切运行正常，大家可以从下载下来，在idea运行，有一个问题，在chrome内核的浏览器上支持度比较好，在其他浏览器的滚动条有点问题！ 注册功能我没有写，我下一条博客准备发我的用python框架flask写的小型商城，那个里面有邮箱注册，到时候大家可以从哪里瞅瞅 希望你的小星星点赞我的github，谢谢 我的github站点：https://github.com/lmx110522/nyist_chat_project.git 谢谢大家花时间看我的博客，万分感谢~~~]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot的配置]]></title>
    <url>%2Flmx110522.github.io%2F2018%2F01%2F15%2FSpringBoot%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[配置文件加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 file:./config/ file:./ classpath:/config/ classpath:/ 加载规则如下： 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； 我们还可以通过spring.config.location来改变默认的配置文件位置 java -jar test.jar –spring.config.location=D:/application.yml 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； 外部配置加载顺序#####SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置 1.命令行参数所有的配置都可以在命令行上进行指定java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context-path=/abc多个配置用空格分开； 配置项=值2.来自java:comp/env的JNDI属性3.Java系统属性（System.getProperties()）4.操作系统环境变量5.RandomValuePropertySource配置的random.*属性值由jar包外向jar包内进行寻找；优先加载带profile6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件再来加载不带profile8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件10.@Configuration注解类上的@PropertySource11.通过SpringApplication.setDefaultProperties指定的默认属性]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring琐碎知识汇总]]></title>
    <url>%2Flmx110522.github.io%2F2018%2F01%2F10%2FSpring%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[SpringBoot学习总结SpringBoot简化spring开发，约定大于配置 优点： 快速创建独立运行的Spring项目以及与主流框架集成 使用嵌入式的Servlet容器,应用无需打成WAR包 starters自动依赖与版本控制 大量的自动配置,简化开发,也可修改默认值 无需配置XML ,无代码生成,开箱即用 准生产环境的运行时应用监控 与云计算的天然集成 使用springboot也跟目前大时代背景有关，现在企业级应用如此庞大，集群，微服务，SOA词汇渐渐进入我们的视野提到了微服务，我们就要看看马丁大叔的个人主页,马丁大叔14年提到了微服务，提倡服务之间应使用restful风格，后来我们将要学习的springcloud采用的就是基于restful风格的架构方案 开发springboot最好用的是IDEA，这是我的百度网盘链接，拿去用吧IDEA工具下载 配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的 application.yml application.properties YAML是”YAML Ain’t a Markup Language”（YAML不是一种置标语言）的递归缩写yml是一种标记语言，yml以数据为中心，相比于xml,xml花费太多的时间在标签上，效率不高 yml语法：1、基本语法k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的123server: port: 80 path: /test 2、值的写法字面量 字符串默认不用加上单引号或者双引号 双引号不会转义特殊字符，例如：”spring \n boot” 输出则是 “spring”换行“boot” 单引号会转义特殊字符，例如：”spring \n boot” 输出则是 “spring \n boot” 对象 通常下面写法：123dog: name: 阿黄 age: 12 也可以下面这种行内写法1dog: &#123;name: 阿黄,age: 12&#125; 数组1234pets: - dog - cat - pig 它也有一个行内写法1pets: [dog,cat,pig] yml语法还支持占位符 随机数 age: ${random.uuid} 使用上面定义好的 1234dog: name: 阿黄 age: $&#123;random.uuid&#125; nickname: 小$&#123;dog.name:狗狗&#125; 狗狗表示是如果加载不到dog.name，狗狗就是就是默认值 注：在yml中，last-name和lastName是表示的一样 从yml得到数据绑定给pojoyml数据123person: username: 旺财 password: 123 @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定，prefix=”person”配置文件中哪个下面的所有属性进行一一映射12345678910111213141516171819202122232425262728293031323334353637383940@Component @ConfigurationProperties(prefix = "person") public class Person &#123; private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 然后我们使用springboot的测试功能```java@RunWith(SpringRunner.class)@SpringBootTestpublic class HelloworldApplicationTests &#123; @Autowired private Person person; @Test public void contextLoads() &#123; System.out.println(person.getUsername()); &#125;&#125; 成功打印出： 旺财，成功绑定 这个用法是springboot中很多底层源码都会用的到,源码摘取： redis属性和yml数据绑定，就是用的这个方法 ConfigurationProperties和Value的对比 @ConfigurationPropertie @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封 支持 不支持 在注解ConfigurationProperties的情况下在类上添加@Validated实现JSR303校验 @PropertySource和@ImportSource区别由于我们使用ConfigurationProperties默认会从application.properties/yml中获取数据，所以，如果我们自己写了一个properties，我们则需要@PropertySource1234567891011121314151617181920212223242526272829303132333435package cn.itcast.helloworld.pojo;import org.hibernate.validator.constraints.Length;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;import org.springframework.validation.annotation.Validated;@Component@PropertySource(value = &#123;"classpath:person.properties"&#125;)@ConfigurationProperties(prefix = "person")@Validatedpublic class Person &#123; @Length(min = 8,max = 16) private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; @ImportSource：导入spring的配置文件，让配置文件生效1@ImportResource(locations = &#123;"classpath:beans.xml"&#125;) profile环境配置，在spring注解的时候有@Profile,和在学习注解版的时候作用是相同的，有两种方法可以根据环境不同来实现配置文件不同 application-dev.properties、application-prod.properties的方式 分区文档快，yml文件可以分区，如下，注意看红线 重要的知识点来了 如何激活环境 运行时配置环境 –spring.profiles.active=dev 项目打包好，我们在命令行可以使用 java jar test.jar –spring.profiles.active=dev 虚拟机参数 -Dspring.profiles.active=dev]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>yml</tag>
        <tag>springboot入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring注解驱动开发（二）]]></title>
    <url>%2Flmx110522.github.io%2F2017%2F12%2F18%2Fspring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[spring注解驱动开发（二）@Import的使用目前我们知道的往ioc容器中注册组件的方式有两种 在类上标注@component、@Service、@Controller、@Repository，然后通过@ComponentScan的方式扫描到ioc容器中 在配置类中需要注册到ioc容器的组件使用@Bean主机的方式出了上面的方法，那么我们再介绍几种方法 @Import可以实现快速注册组件的目的@Import({MyImportSelector.class})然而在ioc中的id是该类的全类名 FactoryBean接口可以实现注册组件的目的我们可以创建一个类实现FactoryBean接口1234567891011121314151617181920public class PersonFactoryBean implements FactoryBean&lt;Person&gt;&#123; //返回对象会加载到ioc容器中 public Person getObject() throws Exception &#123; // TODO Auto-generated method stub System.out.println("成功调用"); return new Person(); &#125; //指定类型 public Class&lt;?&gt; getObjectType() &#123; // TODO Auto-generated method stub return Person.class; &#125; //指定是否是单例模式 public boolean isSingleton() &#123; // TODO Auto-generated method stub return true; &#125;&#125; 然后我们可以测试12345AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class); Object bean = context.getBean("personFactoryBean"); System.out.println(bean.getClass());//打印出来的是class cn.itcast.pojo.Person Object bean1 = context.getBean("&amp;personFactoryBean"); System.out.println(bean1.getClass());//打印出来的是class cn.itcast.config.PersonFactoryBean 注：上面在获取bean的时候，有一个符号&amp;，通过加上这个符号可以获得注册组件自己 ImportSelector接口可以实现注册组件的目的我们把要注册到ioc容器中组件的全类名放在返回的数组中1234567public class MyImportSelector implements ImportSelector&#123; public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; return new String[] &#123;"cn.itcast.pojo.Role","cn.itcast.pojo.Dog"&#125;; &#125;&#125; 记得把MyImportSelector注册到ioc容器中，这里我们采用快速注入的方式@Import({MyImportSelector.class})我们可以一次注册多个组件到容器中 ImportBeanDefinitionRegistrar接口可以实现注册组件的目的123456789101112131415public class MyImportBeanDefinitionRegister implements ImportBeanDefinitionRegistrar&#123; public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; //首先判断ioc中是否有role这个组件，如果有的话，就注册bean boolean flag = registry.containsBeanDefinition("cn.itcast.pojo.Role"); if(flag) &#123; //注册person组件 RootBeanDefinition beanDefinition = new RootBeanDefinition(Person.class); registry.registerBeanDefinition("person",beanDefinition); &#125; &#125;&#125; @Bean中的initMethod、destroyMethod原先我们使用xml配置的方式表示为:1234567891011121314151617181920public class Role &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void init() &#123; System.out.println("容器初始化"); &#125; public void destory() &#123; System.out.println("容器被销毁"); &#125;&#125; 123&lt;bean id="role" class="cn.itcast.pojo.Role" init-method="init" destroy-method="destory"&gt; &lt;property name="name" value="bean生命周期"&gt;&lt;/property&gt;&lt;/bean&gt; 在@Bean中有两个属性1234@Bean(initMethod="init",destroyMethod="destory") public Role role() &#123; return new Role(); &#125; 注：在销毁的时候，单实例容器会销毁，但是多实例，容器不负责销毁，所以在多实例下销毁方法不调用 在初始化的时候，单实例容器运行时，会调用初始化（init）方法，多实例在调用对象的时候创建(执行init的方法) @Value、@PropertySource的使用以前我们使用下面方式给组件赋值123&lt;bean id="dog" class="cn.itcast.pojo.Dog"&gt; &lt;property name="name" value="旺财"&gt;&lt;/property&gt; &lt;/bean&gt; 在注解版中我们可以使用1234@Value("旺财")private String name;@Value("#&#123;2*3&#125;")private String nickName; 当然这种硬编码不太好，所以我们可以加载配置文件中的值，那么引入@PropertySource实现引入配置文件然后使用属性占位符的方式得到12@Value("$&#123;dog.name&#125;")private String name; 当然你也可以使用SPEL表达式得到。12 @Value("#&#123;systemProperties['dog.name']&#125;")private String name; @Autowired、@Qualifier、@Primary注解的使用@Autowired用作组件的自动装配，装配的规则是 首先按照组件的类型从ioc容器中查找，查找到装配完成 如果遇到多个同类型的组件，那么会使用属性名作为查找ioc容器组件的id 如果没有查到到，会报错！但是我们又不想让它报错，那么我们可以使用@Autowired(required=false)当然我们也可以自己指定需要查找组件的id,用@Qualifier(&quot;indexService1&quot;),这样我们就可以去ioc容器中查找id是indexService1的组件同时呢，spring也给我们提供了@Primary，意思是要找此类型的组件，首选此组件12345@Primary @Bean public IndexService indexService1() &#123; return new IndexService(); &#125; 注：@Primary注解使用的时候，就不要使用@Qualifier注解了 spring也支持@Resource(JSR250)和@Inject(JSR330),这些都是java规范@Resource默认按照属性的名称作为组件的id去ioc容器查找，当然我们也可以使用@Resource（name=’indexDao1’）设置@Inject需要导入javax.inject的包，在使用上和@Autowired一样@Autowired可以使用在构造器，方法，属性上面、参数位置，如果组件只有一个有参构造器，参数位置的@Autowired可以省略，还有@Bean中的参数，也不用写@Autowired，都可以从容器中自动装配 @Profile注解的使用Spring为我们提供的可以根据当前环境，动态的激活和切换一系列组件的功能默认的profile是default我们在某个组件上面加上@Profile(&#39;test&#39;),一旦加上之后，就是当环境激活的时候，对应的bean才可以注册到容器中那么如何激活呢 在运行到时候，设置命令行参数的方式 -Dspring.profiles.active=test 可以借助applicationContext方式激活环境，例如：1234567AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();//设置需要激活的环境context.getEnvironment().setActiveProfiles("test","dev");//注册主配置类context.register(MyConfig.class);//启动刷新容器context.refresh();]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring注解驱动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring注解驱动开发（一）]]></title>
    <url>%2Flmx110522.github.io%2F2017%2F12%2F15%2Fspring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[spring注解驱动开发（一）初步介绍 spring注解驱动开发随着springboot这个简洁化开发，约定大于配置的大环境下，spring注解版知识点使用的也开始越来越多，所以我已经学习了基础springboot之后果断停止，开始学习spring注解驱动开发,下面是我总结的一些注解知识,这个页面会一直更新，用于以后的查阅 1、@Configurable注解以及@Bean的使用Configurable表示这个一个配置类，代替原先xml配置之前我们用xml做DI(依赖注入)，现在我们可以通过class的方式来声明一个配置类 xml配置1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"&gt; &lt;bean id="person" class="cn.itcast.pojo.Person"&gt; &lt;property name="username" value="lmx"&gt;&lt;/property&gt; &lt;property name="password" value="123"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 现在可以使用123456789101112131415package cn.itcast.config;import org.springframework.beans.factory.annotation.Configurable;import org.springframework.context.annotation.Bean;import cn.itcast.pojo.Person;@Configurablepublic class MyConfig &#123; @Bean(name="lmx") public Person person() &#123; return new Person("lmz","456"); &#125;&#125; 上面的bean代替旧的即&lt;bean/&gt;可以实现向容器注册组件，其中bean的name属性指的是注册组件在容器中的ID，默认是方法名作为组件的ID 然后通过下面的测试，果然简单有效，赞！1234567891011121314151617181920212223242526package cn.itcast.test;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import cn.itcast.config.MyConfig;import cn.itcast.pojo.Person;public class MainTest &#123; public static void main(String[] args) &#123;// ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");// Person person = (Person)applicationContext.getBean("person");// System.out.println("姓名："+person.getUsername());// System.out.println("密码："+person.getPassword()); AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class); Person bean = context.getBean(Person.class); System.out.println("姓名："+bean.getUsername()); System.out.println("密码："+bean.getPassword()); String[] beanNamesForType = context.getBeanNamesForType(Person.class); for (String string : beanNamesForType) &#123; System.out.println(string); &#125; &#125;&#125; 2、@ComponentScan包扫描注解context:component-scan主要用于扫描对应包下面的注解到容器中，一般有以下注解 @Controller @Service @Repository @Component 对应的xml配置 &lt;context:component-scan base-package=&quot;cn.itcast&quot;/&gt;’ 用class类文件的方式，把下面配置配在config文件的上面，这样可以实现包扫描 @ComponentScan(basePackages= {“cn.itcast”})’ @excludeFilters可以除去不想扫描进容器的注解1234@ComponentScan(basePackages= &#123;"cn.itcast"&#125;,excludeFilters= &#123; @Filter(type=FilterType.ANNOTATION,classes=Controller.class), @Filter(type=FilterType.ANNOTATION,classes=Service.class)&#125;) use-default-filters这个语句主要是关闭默认扫描对应包下面的所有注解 @includeFilters中要把use-default-filters设置成false xml中这样写 &lt;context:component-scan base-package=&quot;cn.itcast&quot; use-default-filters=&quot;false&quot; /&gt; 使用class文件这样写就ok了1234@ComponentScan(basePackages = &#123;"cn.itcast"&#125;,includeFilters = &#123;@Filter(type=FilterType.ANNOTATION,classes=Controller.class),@Filter(type=FilterType.ANNOTATION,classes=Service.class)&#125;,useDefaultFilters = false) 由于java8以上才有@Repeatable这个注解，表示可以注解重复，但是java8以下不支持，所以我们要做兼容性有一个注解@ComponentScans，可以包含多个@ComponentScan 3、 @Scope注解扫描到容器的默认是单实例的我们可以通过scope改变默认值xml中我们是这样来表示scope的1234&lt;bean id="person" class="cn.itcast.pojo.Person" scope="prototype"&gt; &lt;property name="username" value="lmx"&gt;&lt;/property&gt; &lt;property name="password" value="123"&gt;&lt;/property&gt; &lt;/bean&gt; class类方式在@Bean注解上添加@Scope 注： 单实例是ioc容器启动的时候就就把对象创建放进容器了，但多实例是什么时候调用就什么时候创建 例如：@Scope(&#39;prototype&#39;)这个表明扫描进容器的组件是多实例的，当然我们也可以使用@Scope(&#39;singleton&#39;)或者不写，可以实现单实例12345@Scope(value="SCOPE_PROTOTYPE") @Bean(name="lmx") public Person person() &#123; return new Person("lmz","456"); &#125; 4、 @Lazy懒加载的使用把这个注解放在@Bean的上面表示懒加载，即IOC容器启动的时候创建，什么时候使用什么时候创建 注:这个属性主要针对的是单实例的 5、 @Conditional条件注解的使用这个注解在springboot的底层源码用的最多，所以有必要好好深挖一下我写了一个demo1234567891011@Conditional(WindowsCondition.class) @Bean(name="bill") public Person person01() &#123; return new Person("Bill Gates","123"); &#125; @Conditional(LinuxCondition.class) @Bean(name="linus") public Person person02() &#123; return new Person("linus","456"); &#125; 分别创建WindowsCondition、LinuxCondition，都要实现Condition接口12345678910111213141516171819202122232425262728public class LinuxCondition implements Condition&#123; //参数 context 上下文环境 // 参数 metadata 当前注释此注解的信息 public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; // //获得ioc使用的beanfactory// ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();// // //获取类加载器// ClassLoader classLoader = context.getClassLoader();// // //获取bean定义的注册类// BeanDefinitionRegistry registry = context.getRegistry(); // //判断对应的bean是不是在ioc容器中已经存在// boolean isExist = registry.containsBeanDefinition("lmx");// //获取当前系统环境信息 Environment environment = context.getEnvironment(); //获取操作系统属性 String property = environment.getProperty("os.name"); if(property.contains("Linux")) return true; return false; &#125;&#125; 123456789101112public class WindowsCondition implements Condition&#123; public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; // TODO Auto-generated method stub Environment environment = context.getEnvironment(); String property = environment.getProperty("os.name"); if(property.contains("Windows")) return true; return false; &#125;&#125; 然后做测试12345AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class); String[] strings = context.getBeanNamesForType(Person.class); for (String string : strings) &#123; System.out.println(string); &#125; 结果：由于我的系统是Windows，所以ioc容器中注册的组件id是 bill 下一篇还有spring注解驱动开发（二）]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring注解驱动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消息中间件]]></title>
    <url>%2Flmx110522.github.io%2F2017%2F10%2F17%2F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[消息中间件 常用的消息中间件1. ActiveMQ Apache出品的，开发常用2. RabbitMQ 完全支持JMS1.1和J2EE 1.4规范3. kafka Kafka的目的是通过Hadoop的并行加载机制来统一线上和离线的消息处理，也是为了通过集群来提供实时的消息。 消息中间件可以提高系统性能 JMSJMS 是一套消息中间件的技术规范，定义了一系列的接口规范。JMS 定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。 TextMessage–一个字符串对象 MapMessage–一套名称-值对 ObjectMessage–一个序列化的 Java 对象 BytesMessage–一个字节的数据流 StreamMessage – Java 原始值的数据流 对于消息的传递有两种类型： 一种是点对点的，即一个生产者和一个消费者一一对应； 另一种是发布、订阅模式，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收。 消息中间件用的比较多的还是activeMQ点对点模式消息生产者生产消息（点对点模式）1234567891011121314151617181920212223242526272829303132333435363738import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class QueueProducer &#123; public static void main(String[] args) throws JMSException &#123; //创建连接工厂 ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory("tcp://192.168.13.131:61616"); //创建连接 Connection connection = activeMQConnectionFactory.createConnection(); //启动连接 connection.start(); //获取session（会话对象） 参数1:是否启动事物 参数2:消息确认方式 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //创建队列对象 Queue queue = session.createQueue("sms"); //创建消息生产者对象 MessageProducer producer = session.createProducer(queue); //创建消息(文本对象) TextMessage textMessage = session.createTextMessage("你好，jms"); //发送消息 producer.send(textMessage); //关闭连接 producer.close(); session.close(); connection.close(); &#125;&#125; 消费者消费消息（点对点模式）1234567891011121314151617181920212223242526272829303132333435363738394041424344import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class QueueConsumer &#123; public static void main(String[] args) throws JMSException &#123; //创建连接工厂 ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory("tcp://192.168.13.131:61616"); //创建连接 Connection connection = activeMQConnectionFactory.createConnection(); //启动连接 connection.start(); //获取session（会话对象） 参数1:是否启动事物 参数2:消息确认方式 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //创建队列对象 Queue queue = session.createQueue("sms"); //创建消息消费者对象 MessageConsumer consumer = session.createConsumer(queue); //设置监听 consumer.setMessageListener(new MessageListener() &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; try &#123; String messageText = textMessage.getText(); System.out.println("接收到的消息是："+messageText); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); consumer.close(); session.close(); connection.close(); &#125;&#125; 发布订阅模式消息生产者生产消息（发布订阅模式）123456789101112131415161718192021222324252627282930313233343536373839import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class QueueProducer &#123; public static void main(String[] args) throws JMSException &#123; //创建连接工厂 ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory("tcp://192.168.13.131:61616"); //创建连接 Connection connection = activeMQConnectionFactory.createConnection(); //启动连接 connection.start(); //获取session（会话对象） 参数1:是否启动事物 参数2:消息确认方式 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //创建主题对象 Topic topic = session.createTopic("sms2"); //创建消息生产者对象 MessageProducer producer = session.createProducer(topic); //创建消息(文本对象) TextMessage textMessage = session.createTextMessage("你好，jms2"); //发送消息 producer.send(textMessage); //关闭连接 producer.close(); session.close(); connection.close(); &#125;&#125; 消费者消费消息（发布订阅模式）1234567891011121314151617181920212223242526272829303132333435363738394041424344import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class QueueConsumer &#123; public static void main(String[] args) throws JMSException &#123; //创建连接工厂 ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory("tcp://192.168.13.131:61616"); //创建连接 Connection connection = activeMQConnectionFactory.createConnection(); //启动连接 connection.start(); //获取session（会话对象） 参数1:是否启动事物 参数2:消息确认方式 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //创建主题对象 Topic topic = session.createTopic("sms2"); //创建消息消费者对象 MessageConsumer consumer = session.createConsumer(topic); //设置监听 consumer.setMessageListener(new MessageListener() &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; try &#123; String messageText = textMessage.getText(); System.out.println("接收到的消息是："+messageText); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); consumer.close(); session.close(); connection.close(); &#125;&#125; 注意点 发布订阅模式下，生产者发布消息，消费者必须在开启的情况下才可以接受到，否则消息就浪费掉，就消失了。 Spring整合Jms Spring生产者xml文件配置（点对点） 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:amq="http://activemq.apache.org/schema/core" xmlns:jms="http://www.springframework.org/schema/jms" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="cn.itcast.demo"&gt;&lt;/context:component-scan&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://192.168.13.131:61616"/&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name="targetConnectionFactory" ref="targetConnectionFactory"/&gt; &lt;/bean&gt; &lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt; &lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt; &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt; &lt;property name="connectionFactory" ref="connectionFactory"/&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 文本信息--&gt; &lt;bean id="queueTextDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;constructor-arg value="queue_text"/&gt; &lt;/bean&gt; &lt;!--这个是订阅模式 文本信息--&gt; &lt;bean id="topicTextDestination" class="org.apache.activemq.command.ActiveMQTopic"&gt; &lt;constructor-arg value="topic_text"/&gt; &lt;/bean&gt; &lt;/beans&gt; Spring生产者生产消息（点对点）1234567891011121314151617181920import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jms.core.JmsTemplate;import org.springframework.stereotype.Component;import javax.jms.Destination;@Componentpublic class SpringQueueProducer &#123; @Autowired private JmsTemplate jmsTemplate; @Autowired private Destination queueTextDestination; //发送消息 public void sendTextMessage(final String text)&#123; jmsTemplate.convertAndSend(text); &#125;&#125; 123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations="classpath:applicationContext-jms-producer.xml")public class TestQueue &#123; @Autowired private QueueProducer queueProducer; @Test public void testSend()&#123; queueProducer.sendTextMessage("SpringJms-点对点"); &#125; &#125; Spring消费者接收消息（点对点）Spring消费者接收xml配置12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:amq="http://activemq.apache.org/schema/core" xmlns:jms="http://www.springframework.org/schema/jms" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://192.168.25.131:61616"/&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name="targetConnectionFactory" ref="targetConnectionFactory"/&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 文本信息--&gt; &lt;bean id="queueTextDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;constructor-arg value="queue_text"/&gt; &lt;/bean&gt; &lt;!-- 监听类 --&gt; &lt;bean id="myMessageListener" class="cn.itcast.demo.MyMessageListener"&gt;&lt;/bean&gt; &lt;!-- 消息监听容器 --&gt; &lt;bean class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="destination" ref="queueTextDestination" /&gt; &lt;property name="messageListener" ref="myMessageListener" /&gt; &lt;/bean&gt; &lt;/beans&gt; Spring消费者消费消息（点对点）1234567891011121314package cn.itcast.demo;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.TextMessage;public class MyMessageListener implements MessageListener &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; System.out.println("接受到的消息为："+textMessage); &#125;&#125; 123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations="classpath:applicationContext-jms-consumer-queue.xml")public class TestQueue &#123; @Test public void testQueue()&#123; try &#123; System.in.read(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; spring整合jms，对于订阅广播模式，xml配置和点对点一样，我被对应配置已经放在里面了然后只有执行语句不一样 Spring生产者生产消息（发布订阅模式）1234567891011121314151617181920@Componentpublic class TopicProducer &#123; @Autowired private JmsTemplate jmsTemplate; @Autowired private Destination topicTextDestination; /** * 发送文本消息 * @param text */ public void sendTextMessage(final String text)&#123; jmsTemplate.send(topicTextDestination, new MessageCreator() &#123; public Message createMessage(Session session) throws JMSException &#123; return session.createTextMessage(text); &#125; &#125;); &#125;&#125; 12345678910111213141516import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import cn.itcast.demo.TopicProducer;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations="classpath:applicationContext-activemq-producer.xml")public class TestTopic &#123; @Autowired private TopicProducer topicProducer; @Test public void sendTextQueue()&#123; topicProducer.sendTextMessage(); &#125; &#125; Spring消费者消费消息（发布订阅模式）123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations="classpath:applicationContext-jms-consumer-topic.xml")public class TestTopic &#123; @Test public void testTopic()&#123; try &#123; System.in.read(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 上面的代码 1System.in.read(); 是防止程序启动结束就会关闭，所以让窗口一直等待输入 学习总结花了一两天来了解jms以及和spring的整合，用处很大！有以下两点 可以用来在发送短信的功能中，把短信验证码发送到队列中，然后点对点方式让用户接受到，起到了一定程度的削锋 发布订阅模式可以用在集群环境下，由于集群环境下，同一个页面在不同的服务器上存在多份，可以使用发布订阅模式完成同时渲染多个服务器上的相同的页面]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>消息中间件</tag>
        <tag>JMS</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux的chmod赋权限语句]]></title>
    <url>%2Flmx110522.github.io%2F2017%2F02%2F19%2Flinux%E7%9A%84chmod%E8%B5%8B%E6%9D%83%E9%99%90%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[linux下chmod 755的解释很多时候在Linux系统下给安装好的软件赋权限的时候回用的755、555,那么数字表示什么呢？ 普及一下chmod的数字 chmod是Linux下设置文件权限的命令，后面的数字表示不同用户或用户组的权限。 一般是三个数字： 第一个数字表示文件所有者的权限 第二个数字表示与文件所有者同属一个用户组的其他用户的权限 第三个数字表示其它用户组的权限。 权限分为三种：读（r=4），写（w=2），执行（x=1） 。 综合起来还有可读可执行（rx=5=4+1）、可读可写（rw=6=4+2）、可读可写可执行(rwx=7=4+2+1)。 举个例子 1234chmod 755 设置用户的权限为： 1.文件所有者可读可写可执行 --7 2.与文件所有者同属一个用户组的其他用户可读可执行 --5 3.其它用户组可读可执行]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>命令</tag>
      </tags>
  </entry>
</search>
